package templates

import (
	"text/template"
)

var TplHandler = template.Must(template.New("").Parse(`// Code generated by github.com/slasyz/openrest DO NOT EDIT.
package generated

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"

	"github.com/rs/zerolog"
)

var (
	errMethodNotAllowed = errors.New("method not allowed")
)

type Impl interface {
{{range .Methods}}
	{{- .Name}}(*http.Request, *{{.InDTO}}) (int, interface{}, error)
{{end}}

	Error(err error, w http.ResponseWriter, r *http.Request)
}

type Handler struct {
	impl Impl
}

func New(impl Impl) *Handler {
	return &Handler{
		impl: impl,
	}
}

func (h *Handler) read(r *http.Request, dest interface{}) error {
	if r.Method != http.MethodPost { // TODO: implement other methods
		return errMethodNotAllowed
	}

	data, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return fmt.Errorf("error reading body: %w", err)
	}

	err = json.Unmarshal(data, dest)
	if err != nil {
		return fmt.Errorf("error unmarshaling json: %w", err)
	}

	return nil
}

func (h *Handler) write(w http.ResponseWriter, code int, out interface{}) error {
	if code == 0 {
		w.WriteHeader(http.StatusInternalServerError)
	} else {
		w.WriteHeader(code)
	}

	data, err := json.Marshal(out)
	if err != nil {
		return fmt.Errorf("error marshaling json: %w", err)
	}

	_, err = w.Write(data)
	if err != nil {
		return fmt.Errorf("error writing body: %w", err)
	}

	return nil
}

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	mux := http.NewServeMux()

	{{range .Methods}}
	mux.HandleFunc("{{.Path}}", func(w http.ResponseWriter, r *http.Request) {
		var in {{.InDTO}}

		err := h.read(r, &in)
		if err != nil {
			h.impl.Error(err, w, r)
			return
		}

		code, out, err := h.impl.{{.Name}}(r, &in)
		if err != nil {
			h.impl.Error(fmt.Errorf("error in {{.Name}}: %w", err), w, r)
			return
		}

		err = h.write(w, code, out)
		if err != nil {
			h.impl.Error(err, w, r)
			return
		}
	})
	{{end}}
}`))
